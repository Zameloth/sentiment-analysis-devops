trigger:
  branches:
    include:
      - main

variables:
  # Nom EXACT de votre Service Connection ARM
  azureSubscription: 'myserviceconnection'
  # Variables Terraform
  resource_group_name: 'sentimentAnalysis'
  location: 'West Europe'
  acr_name: '4iabdSentimentACR'
  app_service_plan_name: 'myAppPlan'
  webapp_name: '4iabdSentimentAPIWebApp'
  image_name: '4iabdSentimentAPI'
  image_tag: '$(Build.BuildId)'
  terraformDir: '.'  # Dossier racine au lieu de 'terraform'


stages:

  - stage: Terraform
    displayName: 'Terraform Init → Plan → Apply'
    jobs:
      - job: TF
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: Bash@3
            displayName: 'Install Terraform'
            inputs:
              targetType: 'inline'
              script: |
                # Télécharger et installer Terraform
                TERRAFORM_VERSION="1.9.8"
                wget -O terraform.zip https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                unzip terraform.zip
                sudo mv terraform /usr/local/bin/
                terraform --version

          - task: AzureCLI@2
            displayName: 'Test Connection'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Testing Azure connection..."
                az account show
                echo "Connection successful!"

          - task: AzureCLI@2
            displayName: 'Terraform Init'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Current directory: $(pwd)"
                echo "Files in current directory:"
                ls -la
                echo "Initializing Terraform..."
                terraform init

          - task: AzureCLI@2
            displayName: 'Terraform Destroy (Clean Slate)'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Destroying existing resources (if any)..."
                terraform destroy -auto-approve \
                  -var="resource_group_name=$(resource_group_name)" \
                  -var="location=$(location)" \
                  -var="acr_name=$(acr_name)" \
                  -var="app_service_plan_name=$(app_service_plan_name)" \
                  -var="webapp_name=$(webapp_name)" \
                  -var="image_name=$(image_name)" \
                  -var="image_tag=$(image_tag)" || {
                    echo "Destroy failed or nothing to destroy - continuing..."
                    exit 0
                  }

          - task: AzureCLI@2
            displayName: 'Terraform Plan'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                terraform plan \
                  -var="resource_group_name=$(resource_group_name)" \
                  -var="location=$(location)" \
                  -var="acr_name=$(acr_name)" \
                  -var="app_service_plan_name=$(app_service_plan_name)" \
                  -var="webapp_name=$(webapp_name)" \
                  -var="image_name=$(image_name)" \
                  -var="image_tag=$(image_tag)" \
                  -out=tfplan

          - task: AzureCLI@2
            displayName: 'Terraform Apply'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                terraform apply -auto-approve tfplan

  - stage: Build_and_Push
    displayName: 'Build Docker & Push to ACR'
    dependsOn: Terraform
    jobs:
      - job: Docker
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: AzureCLI@2
            displayName: 'Login to ACR'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr login --name $(acr_name)

          - task: Docker@2
            displayName: 'Build & Push image'
            inputs:
              command: buildAndPush
              repository: $(acr_name).azurecr.io/$(image_name)
              Dockerfile: '**/Dockerfile'
              tags: |
                $(image_tag)

  - stage: Deploy_App
    displayName: 'Deploy to App Service'
    dependsOn: Build_and_Push
    jobs:
      - job: Deploy
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: AzureCLI@2
            displayName: 'Update App Service with new image'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Redémarrer l'App Service avec la nouvelle image
                az webapp config container set \
                  --resource-group $(resource_group_name) \
                  --name $(webapp_name) \
                  --docker-custom-image-name $(acr_name).azurecr.io/$(image_name):$(image_tag)
                
                # Redémarrer l'App Service
                az webapp restart \
                  --resource-group $(resource_group_name) \
                  --name $(webapp_name)

  - stage: Smoke_Test
    displayName: 'Smoke Tests'
    dependsOn: Deploy_App
    jobs:
      - job: Test
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: AzureCLI@2
            displayName: 'Healthcheck & Predict'
            inputs:
              connectedServiceNameARM: 'myserviceconnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                URL=$(az webapp show \
                  --resource-group $(resource_group_name) \
                  --name $(webapp_name) \
                  --query defaultHostName -o tsv)
                echo "Health:" && curl -fsS https://$URL/health
                echo "Predict:" && curl -fsS -X POST https://$URL/predict \
                  -H "Content-Type: application/json" \
                  -d '{"text":"Test de déploiement"}'